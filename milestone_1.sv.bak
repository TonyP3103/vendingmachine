module milestone_1(clk, rst, nickel, dime, quarter, total,result_comp);
    input logic clk, rst;
    input logic nickel, dime, quarter;
    output logic [4:0] total;
    output logic [4:0] result_comp;

    logic [3:0] coin_value;
    logic [4:0] new_total;
    logic cout;
    logic acc_reset;
    logic [3:0] comp_input;

    typedef enum logic [1:0] {  RST = 2'b00,
                            ACCUMULATE = 2'b01,
                            DONE = 2'b10} state_t;

state_t state_q, state_d;

    always_ff @(posedge clk or negedge rst) begin
        if (!rst)
            state_q <= RST;
        else
            state_q <= state_d;
    end
    always_comb begin
        state_d = state_q; // Default state
        case (state_q)
            RST: begin
                if (!rst) begin
                    acc_reset = 1'b1;
                    state_d = RST;
                    comp_input = 4'b0100;
                end else begin
                    acc_reset = 1'b0;
                    comp_input = 4'b0100;
                    state_d = ACCUMULATE;
            end
            end
            ACCUMULATE: begin
                acc_reset = 1'b0;
                if (new_total[4] | new_total[3] | new_total[2]) begin
                    comp_input = new_total[3:0];
                    state_d = DONE;
                end else begin
                    comp_input = 4'b0100;
                    state_d = ACCUMULATE;
            end
            end
            DONE: begin
                acc_reset = 1'b1;
                state_d = DONE;
            end
            default: begin
                state_d = RST;
            end
        endcase
    end

    coin_insert coin_insert_1 (
        .nickel(nickel),
        .dime(dime),
        .quarter(quarter),
        .coin_out(coin_value)
    );

    adder3bit accumulate (
        .a(coin_value),
        .b(total[2:0]),
        .cin(1'b0),
        .sum(new_total),
        .cout(cout)
    );

    adder3bit comparator (
        .a(comp_input),
        .b(4'b0100),
        .cin(1'b1),
        .sum(result_comp),
        .cout()
    );

    always_ff @(posedge clk or negedge rst) begin
        if (!rst) begin
            total <= 4'b0000;
        end else if (acc_reset) begin
            total <= 4'b0000;
        end else begin
            total <= new_total;
        end
    end


endmodule
